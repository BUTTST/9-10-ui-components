---
title: "Framer Motion 動畫系統"
description: "使用 Framer Motion 建立流暢的 UI 動畫，包含 Variants、AnimatePresence 和 Layout Animations"
domain: "frontend"
tech: ["react", "framer-motion", "typescript", "tailwind"]
intent: ["微互動", "滾動動效"]
category: "motion"
tags: ["動畫", "互動", "手勢", "過場效果"]
updated: "2024-01-15"
design_intent:
  goal: "建立一套完整的動畫系統，提升用戶體驗"
  constraints: ["要考慮效能", "需支援無障礙", "要有動畫偏好設定"]
  variations: ["入場動畫", "過場動畫", "手勢動畫", "佈局動畫"]
react_patterns: ["custom hooks", "animation variants", "gesture handlers", "layout animations"]
tailwind_tokens:
  animations: "animate-pulse, animate-bounce, animate-spin"
  transforms: "transform, scale-105, translate-y-4"
next_features: ["client components", "dynamic imports", "performance optimization"]
ts_types: ["MotionProps", "Variants", "Transition", "GestureHandlers"]
ai_prompt: |
  請幫我建立一個現代化的 Framer Motion 動畫系統，要求如下：

  技術規格：
  - Framer Motion + React + TypeScript
  - 支援動畫偏好設定 (prefers-reduced-motion)
  - 效能優化的動畫實作
  - 手勢支援 (拖拽、點擊、hover)

  動畫類型：
  1. 入場/離場動畫
  2. 列表項目過場動畫
  3. 佈局變化動畫
  4. 手勢互動動畫
  5. 滾動觸發動畫

  功能需求：
  1. Variants 系統管理
  2. AnimatePresence 處理
  3. 拖拽功能
  4. 手勢回饋
  5. 動畫編排

  無障礙需求：
  - 尊重用戶的動畫偏好
  - 提供動畫開關選項
  - 確保動畫不影響功能使用

  請提供完整的動畫系統，包含常用動畫變體和使用範例。
links:
  - label: "Framer Motion Documentation"
    url: "https://www.framer.com/motion/"
  - label: "Animation Best Practices"
    url: "https://web.dev/animations/"
---

# Framer Motion 動畫系統

Framer Motion 是一個強大的 React 動畫庫，提供了直觀的 API 來建立流暢、高效能的動畫效果。本文將介紹如何建立一個完整的動畫系統。

## 核心概念

### 基礎動畫變體

```tsx
'use client'

import { motion, Variants } from 'framer-motion'

// 常用動畫變體
export const fadeInUp: Variants = {
  hidden: {
    opacity: 0,
    y: 20
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.6,
      ease: [0.4, 0, 0.2, 1]
    }
  }
}

export const scaleIn: Variants = {
  hidden: {
    opacity: 0,
    scale: 0.8
  },
  visible: {
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: 'backOut'
    }
  }
}

export const slideInLeft: Variants = {
  hidden: {
    opacity: 0,
    x: -50
  },
  visible: {
    opacity: 1,
    x: 0,
    transition: {
      duration: 0.5,
      ease: 'easeOut'
    }
  }
}

// 容器動畫變體（用於列表項目）
export const staggerContainer: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.1,
      delayChildren: 0.2
    }
  }
}

export const staggerItem: Variants = {
  hidden: { opacity: 0, y: 20 },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.5,
      ease: 'easeOut'
    }
  }
}
```

### 動畫 Hook

```tsx
import { useReducedMotion } from 'framer-motion'
import { useEffect, useState } from 'react'

// 動畫偏好 Hook
export const useAnimationPreference = () => {
  const shouldReduceMotion = useReducedMotion()
  const [animationsEnabled, setAnimationsEnabled] = useState(true)

  useEffect(() => {
    const saved = localStorage.getItem('animations-enabled')
    if (saved !== null) {
      setAnimationsEnabled(JSON.parse(saved))
    }
  }, [])

  const toggleAnimations = () => {
    const newValue = !animationsEnabled
    setAnimationsEnabled(newValue)
    localStorage.setItem('animations-enabled', JSON.stringify(newValue))
  }

  const shouldAnimate = animationsEnabled && !shouldReduceMotion

  return {
    shouldAnimate,
    animationsEnabled,
    toggleAnimations,
    reducedMotion: shouldReduceMotion
  }
}

// 滾動動畫 Hook
export const useScrollAnimation = (threshold = 0.1) => {
  return {
    initial: 'hidden',
    whileInView: 'visible',
    viewport: { once: true, amount: threshold }
  }
}
```

## 動畫元件範例

### 動畫卡片

```tsx
'use client'

import { motion } from 'framer-motion'
import { useAnimationPreference } from '@/hooks/useAnimationPreference'

interface AnimatedCardProps {
  children: React.ReactNode
  delay?: number
  className?: string
}

export const AnimatedCard = ({ children, delay = 0, className }: AnimatedCardProps) => {
  const { shouldAnimate } = useAnimationPreference()

  const cardVariants = {
    hidden: {
      opacity: shouldAnimate ? 0 : 1,
      y: shouldAnimate ? 20 : 0,
      scale: shouldAnimate ? 0.95 : 1
    },
    visible: {
      opacity: 1,
      y: 0,
      scale: 1,
      transition: {
        duration: shouldAnimate ? 0.5 : 0,
        delay: shouldAnimate ? delay : 0,
        ease: 'easeOut'
      }
    },
    hover: shouldAnimate ? {
      y: -8,
      scale: 1.02,
      transition: {
        duration: 0.2,
        ease: 'easeOut'
      }
    } : {},
    tap: shouldAnimate ? {
      scale: 0.98,
      transition: {
        duration: 0.1
      }
    } : {}
  }

  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      whileHover="hover"
      whileTap="tap"
      className={className}
    >
      {children}
    </motion.div>
  )
}
```

### 列表動畫

```tsx
'use client'

import { motion, AnimatePresence } from 'framer-motion'

interface AnimatedListProps {
  items: Array<{ id: string; content: React.ReactNode }>
  className?: string
}

export const AnimatedList = ({ items, className }: AnimatedListProps) => {
  const { shouldAnimate } = useAnimationPreference()

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: shouldAnimate ? 0.1 : 0,
        delayChildren: shouldAnimate ? 0.2 : 0
      }
    }
  }

  const itemVariants = {
    hidden: {
      opacity: shouldAnimate ? 0 : 1,
      x: shouldAnimate ? -20 : 0
    },
    visible: {
      opacity: 1,
      x: 0,
      transition: {
        duration: shouldAnimate ? 0.4 : 0,
        ease: 'easeOut'
      }
    },
    exit: {
      opacity: shouldAnimate ? 0 : 1,
      x: shouldAnimate ? 20 : 0,
      transition: {
        duration: shouldAnimate ? 0.3 : 0,
        ease: 'easeIn'
      }
    }
  }

  return (
    <motion.div
      variants={containerVariants}
      initial="hidden"
      animate="visible"
      className={className}
    >
      <AnimatePresence mode="popLayout">
        {items.map((item) => (
          <motion.div
            key={item.id}
            variants={itemVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            layout={shouldAnimate}
            className="mb-4"
          >
            {item.content}
          </motion.div>
        ))}
      </AnimatePresence>
    </motion.div>
  )
}
```

### 拖拽元件

```tsx
'use client'

import { motion, useDragControls, PanInfo } from 'framer-motion'
import { useRef, useState } from 'react'

interface DraggableCardProps {
  children: React.ReactNode
  onDragEnd?: (info: PanInfo) => void
  className?: string
}

export const DraggableCard = ({ children, onDragEnd, className }: DraggableCardProps) => {
  const [isDragging, setIsDragging] = useState(false)
  const dragControls = useDragControls()
  const constraintsRef = useRef<HTMLDivElement>(null)

  const handleDragStart = () => {
    setIsDragging(true)
  }

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    setIsDragging(false)
    onDragEnd?.(info)
  }

  return (
    <div ref={constraintsRef} className="relative w-full h-full">
      <motion.div
        drag
        dragControls={dragControls}
        dragConstraints={constraintsRef}
        dragElastic={0.1}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        whileDrag={{
          scale: 1.05,
          rotate: 5,
          zIndex: 1000,
          cursor: 'grabbing'
        }}
        className={cn(
          'cursor-grab select-none',
          isDragging && 'shadow-2xl',
          className
        )}
        style={{
          touchAction: 'none' // 防止觸控滾動衝突
        }}
      >
        {children}
      </motion.div>
    </div>
  )
}
```

### 手勢回饋元件

```tsx
'use client'

import { motion } from 'framer-motion'

interface GestureButtonProps {
  children: React.ReactNode
  onClick?: () => void
  className?: string
}

export const GestureButton = ({ children, onClick, className }: GestureButtonProps) => {
  const { shouldAnimate } = useAnimationPreference()

  return (
    <motion.button
      onClick={onClick}
      whileHover={shouldAnimate ? { scale: 1.05 } : {}}
      whileTap={shouldAnimate ? { scale: 0.95 } : {}}
      whileFocus={shouldAnimate ? { scale: 1.02 } : {}}
      transition={{
        type: 'spring',
        stiffness: 400,
        damping: 10
      }}
      className={cn(
        'focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500',
        className
      )}
    >
      {children}
    </motion.button>
  )
}
```

## 複雜動畫範例

### 多階段動畫

```tsx
'use client'

import { motion, useAnimation } from 'framer-motion'
import { useEffect } from 'react'

export const MultiStageAnimation = () => {
  const controls = useAnimation()

  useEffect(() => {
    const sequence = async () => {
      // 第一階段：淡入
      await controls.start({
        opacity: 1,
        transition: { duration: 0.5 }
      })
      
      // 第二階段：放大
      await controls.start({
        scale: 1.2,
        transition: { duration: 0.3 }
      })
      
      // 第三階段：回到正常大小並旋轉
      await controls.start({
        scale: 1,
        rotate: 360,
        transition: { duration: 0.5 }
      })
    }

    sequence()
  }, [controls])

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={controls}
      className="w-32 h-32 bg-blue-500 rounded-lg"
    />
  )
}
```

### 路徑動畫

```tsx
'use client'

import { motion } from 'framer-motion'

export const PathAnimation = () => {
  const draw = {
    hidden: { pathLength: 0, opacity: 0 },
    visible: (i: number) => {
      const delay = 1 + i * 0.5
      return {
        pathLength: 1,
        opacity: 1,
        transition: {
          pathLength: { delay, type: 'spring', duration: 1.5, bounce: 0 },
          opacity: { delay, duration: 0.01 }
        }
      }
    }
  }

  return (
    <motion.svg
      width="600"
      height="600"
      viewBox="0 0 600 600"
      initial="hidden"
      animate="visible"
      className="w-full h-auto"
    >
      <motion.circle
        cx="100"
        cy="100"
        r="80"
        stroke="#ff0055"
        strokeWidth="4"
        fill="transparent"
        variants={draw}
        custom={1}
      />
      <motion.line
        x1="220"
        y1="30"
        x2="360"
        y2="170"
        stroke="#00cc88"
        strokeWidth="4"
        variants={draw}
        custom={2}
      />
      <motion.rect
        width="140"
        height="140"
        x="410"
        y="30"
        rx="20"
        stroke="#0099ff"
        strokeWidth="4"
        fill="transparent"
        variants={draw}
        custom={3}
      />
    </motion.svg>
  )
}
```

## 效能優化

### Layout 動畫優化

```tsx
// ❌ 避免：會觸發重排的動畫
const badAnimation = {
  width: '100%',
  height: '200px'
}

// ✅ 推薦：只使用 transform 和 opacity
const goodAnimation = {
  scale: 1.2,
  opacity: 0.8
}

// Layout 動畫的正確使用
export const LayoutAnimationExample = () => {
  const [isExpanded, setIsExpanded] = useState(false)

  return (
    <motion.div
      layout
      onClick={() => setIsExpanded(!isExpanded)}
      className={cn(
        'bg-white rounded-lg p-4 cursor-pointer',
        isExpanded ? 'w-full' : 'w-64'
      )}
      transition={{
        layout: { duration: 0.3, ease: 'easeInOut' }
      }}
    >
      <motion.h3 layout="position">
        點擊展開/收合
      </motion.h3>
      {isExpanded && (
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ delay: 0.1 }}
        >
          這是展開後的內容
        </motion.p>
      )}
    </motion.div>
  )
}
```

### 動畫設定面板

```tsx
'use client'

import { motion } from 'framer-motion'
import { useAnimationPreference } from '@/hooks/useAnimationPreference'

export const AnimationSettings = () => {
  const { animationsEnabled, toggleAnimations, reducedMotion } = useAnimationPreference()

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm"
    >
      <h3 className="text-lg font-semibold mb-4">動畫設定</h3>
      
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <label htmlFor="animations-toggle" className="text-sm font-medium">
            啟用動畫效果
          </label>
          <button
            id="animations-toggle"
            onClick={toggleAnimations}
            className={cn(
              'relative inline-flex h-6 w-11 items-center rounded-full transition-colors',
              animationsEnabled ? 'bg-blue-600' : 'bg-gray-200 dark:bg-gray-700'
            )}
            role="switch"
            aria-checked={animationsEnabled}
          >
            <span
              className={cn(
                'inline-block h-4 w-4 transform rounded-full bg-white transition-transform',
                animationsEnabled ? 'translate-x-6' : 'translate-x-1'
              )}
            />
          </button>
        </div>

        {reducedMotion && (
          <div className="text-sm text-amber-600 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/20 p-3 rounded-lg">
            您的系統設定偏好減少動畫效果，部分動畫可能不會顯示。
          </div>
        )}

        <div className="text-xs text-gray-500 dark:text-gray-400">
          關閉動畫可以提升效能並減少視覺干擾
        </div>
      </div>
    </motion.div>
  )
}
```

Framer Motion 提供了強大而直觀的動畫能力，通過合理的使用可以大幅提升用戶體驗。記住要始終考慮效能和無障礙性，確保動畫為功能服務而不是成為障礙。