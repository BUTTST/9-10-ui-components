---
title: "兩欄佈局設計與實作"
description: "響應式兩欄佈局，主內容區配側邊欄，支援 sticky 定位、焦點順序管理與行動版自適應"
domain: "frontend"
tech: ["react", "tailwind", "nextjs", "typescript"]
intent: ["側邊欄", "導覽列"]
category: "layout"
tags: ["佈局", "響應式", "導航", "無障礙", "sticky"]
updated: "2024-01-15"
design_intent:
  goal: "建立靈活的兩欄佈局系統，適用於各種內容展示場景"
  constraints: ["側邊欄必須支援 sticky", "小螢幕要能轉單欄", "焦點順序要合理"]
  variations: ["固定側邊欄", "可摺疊側邊欄", "右側邊欄", "多層級導航"]
react_patterns: ["layout components", "context for sidebar state", "compound components", "render props"]
tailwind_tokens:
  layout: "grid grid-cols-1 lg:grid-cols-4, flex flex-col lg:flex-row"
  spacing: "gap-6 lg:gap-8, p-4 lg:p-6"
  responsive: "hidden lg:block, lg:sticky lg:top-6"
  colors: "bg-white dark:bg-gray-900, border-gray-200 dark:border-gray-700"
next_features: ["App Router layouts", "loading.tsx", "not-found.tsx", "usePathname"]
ts_types: ["LayoutProps", "SidebarProps", "MainContentProps", "NavigationItem"]
ai_prompt: |
  請幫我建立一個現代化的兩欄佈局系統，要求如下：

  技術規格：
  - Next.js App Router
  - TypeScript 嚴格型別
  - Tailwind CSS 響應式設計
  - 完整的無障礙支援

  佈局需求：
  1. 左側邊欄（可選右側）
  2. 主內容區域
  3. 側邊欄支援 sticky 定位
  4. 響應式：小螢幕轉單欄
  5. 可摺疊的行動版選單

  功能需求：
  1. 側邊欄狀態管理（開啟/關閉）
  2. 導航項目的 active 狀態
  3. 鍵盤導航支援
  4. 平滑的開關動畫

  無障礙需求：
  - 正確的 landmark 角色
  - 合理的 Tab 鍵順序
  - 螢幕閱讀器友善
  - skip links 支援

  請提供完整的佈局系統，包含型別定義、元件實作和使用範例。
links:
  - label: "CSS Grid Layout Guide"
    url: "https://css-tricks.com/snippets/css/complete-guide-grid/"
  - label: "Tailwind Layout Examples"
    url: "https://tailwindui.com/components/application-ui/layout"
---

# 兩欄佈局設計與實作

兩欄佈局是 Web 應用中最常見的佈局模式之一，特別適用於內容管理系統、文檔網站、和儀表板應用。本文將詳細介紹如何建立一個功能完整、響應式的兩欄佈局系統。

## 設計原則

一個優秀的兩欄佈局應該：
- **響應式**：在不同螢幕尺寸下都能良好工作
- **可及性**：支援鍵盤導航和螢幕閱讀器
- **效能**：避免不必要的重新渲染
- **靈活性**：支援不同的內容類型和互動模式

## 核心架構

### TypeScript 型別定義

```typescript
// 導航項目型別
export interface NavigationItem {
  id: string
  title: string
  href: string
  icon?: React.ComponentType<{ className?: string }>
  badge?: string | number
  children?: NavigationItem[]
  isExternal?: boolean
}

// 佈局屬性
export interface TwoColumnLayoutProps {
  sidebar: React.ReactNode
  children: React.ReactNode
  sidebarWidth?: 'sm' | 'md' | 'lg'
  sidebarPosition?: 'left' | 'right'
  sidebarSticky?: boolean
  collapsible?: boolean
  defaultCollapsed?: boolean
  className?: string
}

// 側邊欄屬性
export interface SidebarProps {
  navigation: NavigationItem[]
  currentPath?: string
  isCollapsed?: boolean
  onToggle?: () => void
  width?: 'sm' | 'md' | 'lg'
  position?: 'left' | 'right'
  className?: string
}

// 主內容區屬性
export interface MainContentProps {
  children: React.ReactNode
  maxWidth?: 'none' | 'prose' | 'screen-xl'
  padding?: 'none' | 'sm' | 'md' | 'lg'
  className?: string
}

// 佈局上下文
export interface LayoutContextValue {
  sidebarCollapsed: boolean
  toggleSidebar: () => void
  sidebarWidth: string
  breakpoint: 'mobile' | 'tablet' | 'desktop'
}
```

### 佈局上下文

```tsx
'use client'

import { createContext, useContext, useState, useEffect } from 'react'

const LayoutContext = createContext<LayoutContextValue | undefined>(undefined)

export const useLayout = () => {
  const context = useContext(LayoutContext)
  if (!context) {
    throw new Error('useLayout must be used within LayoutProvider')
  }
  return context
}

export const LayoutProvider = ({ 
  children, 
  defaultCollapsed = false 
}: { 
  children: React.ReactNode
  defaultCollapsed?: boolean 
}) => {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(defaultCollapsed)
  const [breakpoint, setBreakpoint] = useState<'mobile' | 'tablet' | 'desktop'>('desktop')

  // 響應式斷點檢測
  useEffect(() => {
    const checkBreakpoint = () => {
      if (window.innerWidth < 768) {
        setBreakpoint('mobile')
        setSidebarCollapsed(true) // 行動版預設摺疊
      } else if (window.innerWidth < 1024) {
        setBreakpoint('tablet')
      } else {
        setBreakpoint('desktop')
      }
    }

    checkBreakpoint()
    window.addEventListener('resize', checkBreakpoint)
    return () => window.removeEventListener('resize', checkBreakpoint)
  }, [])

  const toggleSidebar = () => {
    setSidebarCollapsed(prev => !prev)
  }

  const sidebarWidth = sidebarCollapsed ? 'w-0' : 'w-64 lg:w-80'

  return (
    <LayoutContext.Provider value={{
      sidebarCollapsed,
      toggleSidebar,
      sidebarWidth,
      breakpoint
    }}>
      {children}
    </LayoutContext.Provider>
  )
}
```

### 主要佈局元件

```tsx
'use client'

import { forwardRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { cn } from '@/lib/utils'
import { useLayout } from './LayoutContext'

const TwoColumnLayout = forwardRef<HTMLDivElement, TwoColumnLayoutProps>(({
  sidebar,
  children,
  sidebarWidth = 'md',
  sidebarPosition = 'left',
  sidebarSticky = true,
  collapsible = true,
  className,
  ...props
}, ref) => {
  const { sidebarCollapsed, breakpoint } = useLayout()

  // 寬度對應
  const widthClasses = {
    sm: 'w-56',
    md: 'w-64 lg:w-72',
    lg: 'w-72 lg:w-80'
  }

  const sidebarWidthClass = widthClasses[sidebarWidth]
  const isDesktop = breakpoint === 'desktop'
  const showSidebar = isDesktop || !sidebarCollapsed

  return (
    <div
      ref={ref}
      className={cn(
        'min-h-screen bg-gray-50 dark:bg-gray-900',
        className
      )}
      {...props}
    >
      {/* Skip Navigation */}
      <a
        href="#main-content"
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 z-50 bg-blue-600 text-white px-4 py-2 rounded-lg"
      >
        跳至主要內容
      </a>

      <div className="flex">
        {/* 側邊欄 */}
        <AnimatePresence mode="wait">
          {showSidebar && (
            <motion.aside
              initial={{ x: sidebarPosition === 'left' ? -320 : 320, opacity: 0 }}
              animate={{ x: 0, opacity: 1 }}
              exit={{ x: sidebarPosition === 'left' ? -320 : 320, opacity: 0 }}
              transition={{ duration: 0.3, ease: 'easeInOut' }}
              className={cn(
                'fixed inset-y-0 z-40 bg-white dark:bg-gray-900 border-gray-200 dark:border-gray-700',
                sidebarPosition === 'left' ? 'left-0 border-r' : 'right-0 border-l',
                sidebarWidthClass,
                isDesktop && 'relative',
                sidebarSticky && isDesktop && 'sticky top-0 h-screen overflow-y-auto'
              )}
              role="complementary"
              aria-label="側邊導航"
            >
              {sidebar}
            </motion.aside>
          )}
        </AnimatePresence>

        {/* 行動版遮罩 */}
        <AnimatePresence>
          {!isDesktop && !sidebarCollapsed && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 z-30 bg-gray-600 bg-opacity-75"
              onClick={() => useLayout().toggleSidebar()}
            />
          )}
        </AnimatePresence>

        {/* 主內容區 */}
        <main
          id="main-content"
          className={cn(
            'flex-1 min-w-0',
            isDesktop && !sidebarCollapsed && sidebarPosition === 'left' && 'ml-0',
            isDesktop && !sidebarCollapsed && sidebarPosition === 'right' && 'mr-0'
          )}
          role="main"
        >
          {children}
        </main>
      </div>
    </div>
  )
})

TwoColumnLayout.displayName = 'TwoColumnLayout'
```

### 側邊欄元件

```tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { 
  faChevronDown, 
  faChevronRight, 
  faTimes,
  faExternalLinkAlt
} from '@fortawesome/free-solid-svg-icons'
import { useLayout } from './LayoutContext'

export const Sidebar = ({
  navigation,
  currentPath,
  width = 'md',
  position = 'left',
  className
}: SidebarProps) => {
  const pathname = usePathname()
  const { toggleSidebar, breakpoint } = useLayout()
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set())
  
  const activePath = currentPath || pathname

  const toggleExpanded = (itemId: string) => {
    const newExpanded = new Set(expandedItems)
    if (newExpanded.has(itemId)) {
      newExpanded.delete(itemId)
    } else {
      newExpanded.add(itemId)
    }
    setExpandedItems(newExpanded)
  }

  const renderNavigationItem = (item: NavigationItem, level: number = 0) => {
    const isActive = activePath === item.href
    const isExpanded = expandedItems.has(item.id)
    const hasChildren = item.children && item.children.length > 0
    
    return (
      <div key={item.id}>
        {/* 導航項目 */}
        <div className={cn('relative', level > 0 && 'ml-4')}>
          {hasChildren ? (
            // 可展開項目
            <button
              onClick={() => toggleExpanded(item.id)}
              className={cn(
                'w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors',
                'hover:bg-gray-100 dark:hover:bg-gray-800',
                'focus:outline-none focus:ring-2 focus:ring-blue-500',
                isActive && 'bg-blue-50 text-blue-700 dark:bg-blue-950 dark:text-blue-300'
              )}
              aria-expanded={isExpanded}
              aria-controls={`submenu-${item.id}`}
            >
              {item.icon && (
                <item.icon className="flex-shrink-0 w-5 h-5" />
              )}
              <span className="flex-1 font-medium">{item.title}</span>
              {item.badge && (
                <span className="flex-shrink-0 bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">
                  {item.badge}
                </span>
              )}
              <FontAwesomeIcon
                icon={isExpanded ? faChevronDown : faChevronRight}
                className="flex-shrink-0 w-4 h-4 text-gray-400"
              />
            </button>
          ) : (
            // 連結項目
            <Link
              href={item.href}
              className={cn(
                'flex items-center gap-3 px-3 py-2 rounded-lg transition-colors',
                'hover:bg-gray-100 dark:hover:bg-gray-800',
                'focus:outline-none focus:ring-2 focus:ring-blue-500',
                isActive && 'bg-blue-50 text-blue-700 dark:bg-blue-950 dark:text-blue-300'
              )}
              target={item.isExternal ? '_blank' : undefined}
              rel={item.isExternal ? 'noopener noreferrer' : undefined}
              aria-current={isActive ? 'page' : undefined}
            >
              {item.icon && (
                <item.icon className="flex-shrink-0 w-5 h-5" />
              )}
              <span className="flex-1 font-medium">{item.title}</span>
              {item.badge && (
                <span className="flex-shrink-0 bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">
                  {item.badge}
                </span>
              )}
              {item.isExternal && (
                <FontAwesomeIcon
                  icon={faExternalLinkAlt}
                  className="flex-shrink-0 w-3 h-3 text-gray-400"
                />
              )}
            </Link>
          )}
        </div>

        {/* 子項目 */}
        <AnimatePresence>
          {hasChildren && isExpanded && (
            <motion.div
              id={`submenu-${item.id}`}
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="mt-1 space-y-1">
                {item.children!.map(child => renderNavigationItem(child, level + 1))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    )
  }

  return (
    <div className={cn('flex flex-col h-full', className)}>
      {/* 標題列 */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
          導航選單
        </h2>
        {breakpoint !== 'desktop' && (
          <button
            onClick={toggleSidebar}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800"
            aria-label="關閉側邊欄"
          >
            <FontAwesomeIcon icon={faTimes} className="w-5 h-5" />
          </button>
        )}
      </div>

      {/* 導航內容 */}
      <nav className="flex-1 p-4 space-y-1 overflow-y-auto" role="navigation">
        {navigation.map(item => renderNavigationItem(item))}
      </nav>

      {/* 底部區域（可選） */}
      <div className="p-4 border-t border-gray-200 dark:border-gray-700">
        <div className="text-xs text-gray-500 dark:text-gray-400 text-center">
          © 2024 Your App
        </div>
      </div>
    </div>
  )
}
```

### 主內容區元件

```tsx
export const MainContent = ({
  children,
  maxWidth = 'screen-xl',
  padding = 'md',
  className
}: MainContentProps) => {
  const paddingClasses = {
    none: '',
    sm: 'p-4',
    md: 'p-6 lg:p-8',
    lg: 'p-8 lg:p-12'
  }

  const maxWidthClasses = {
    none: '',
    prose: 'max-w-prose',
    'screen-xl': 'max-w-screen-xl'
  }

  return (
    <div className={cn(
      'min-h-screen bg-white dark:bg-gray-900',
      paddingClasses[padding],
      className
    )}>
      <div className={cn(
        'mx-auto',
        maxWidthClasses[maxWidth]
      )}>
        {children}
      </div>
    </div>
  )
}
```

## 使用範例

### 基礎用法

```tsx
'use client'

import { 
  TwoColumnLayout, 
  Sidebar, 
  MainContent, 
  LayoutProvider 
} from '@/components/Layout'
import { 
  faHome, 
  faUser, 
  faCog, 
  faChartBar 
} from '@fortawesome/free-solid-svg-icons'

const navigationItems: NavigationItem[] = [
  {
    id: 'dashboard',
    title: '儀表板',
    href: '/dashboard',
    icon: faHome
  },
  {
    id: 'analytics',
    title: '分析報告',
    href: '/analytics',
    icon: faChartBar,
    badge: 'New'
  },
  {
    id: 'users',
    title: '用戶管理',
    href: '/users',
    icon: faUser,
    children: [
      {
        id: 'users-list',
        title: '用戶列表',
        href: '/users/list'
      },
      {
        id: 'users-roles',
        title: '角色權限',
        href: '/users/roles'
      }
    ]
  },
  {
    id: 'settings',
    title: '設定',
    href: '/settings',
    icon: faCog
  }
]

export default function AppLayout({
  children
}: {
  children: React.ReactNode
}) {
  return (
    <LayoutProvider>
      <TwoColumnLayout
        sidebar={
          <Sidebar
            navigation={navigationItems}
            width="md"
          />
        }
      >
        <MainContent>
          {children}
        </MainContent>
      </TwoColumnLayout>
    </LayoutProvider>
  )
}
```

### 進階配置

```tsx
// 右側邊欄配置
export const RightSidebarLayout = ({ children }: { children: React.ReactNode }) => (
  <LayoutProvider defaultCollapsed={false}>
    <TwoColumnLayout
      sidebarPosition="right"
      sidebarWidth="lg"
      sidebar={<TableOfContents />}
    >
      <MainContent maxWidth="prose" padding="lg">
        {children}
      </MainContent>
    </TwoColumnLayout>
  </LayoutProvider>
)

// 可摺疊側邊欄
export const CollapsibleLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <LayoutProvider defaultCollapsed={true}>
      <TwoColumnLayout
        collapsible
        sidebar={<CompactSidebar />}
      >
        <MainContent>
          <div className="flex items-center justify-between mb-6">
            <h1 className="text-2xl font-bold">頁面標題</h1>
            <SidebarToggleButton />
          </div>
          {children}
        </MainContent>
      </TwoColumnLayout>
    </LayoutProvider>
  )
}

// 側邊欄切換按鈕
const SidebarToggleButton = () => {
  const { toggleSidebar, sidebarCollapsed } = useLayout()
  
  return (
    <button
      onClick={toggleSidebar}
      className="lg:hidden p-2 rounded-lg bg-gray-100 hover:bg-gray-200 dark:bg-gray-800 dark:hover:bg-gray-700"
      aria-label={sidebarCollapsed ? '開啟側邊欄' : '關閉側邊欄'}
    >
      <FontAwesomeIcon 
        icon={sidebarCollapsed ? faBars : faTimes} 
        className="w-5 h-5" 
      />
    </button>
  )
}
```

## 響應式處理

### 斷點策略

```tsx
// 響應式 Hook
export const useResponsive = () => {
  const [breakpoint, setBreakpoint] = useState<'mobile' | 'tablet' | 'desktop'>('desktop')
  const [windowSize, setWindowSize] = useState({ width: 0, height: 0 })

  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth
      const height = window.innerHeight
      
      setWindowSize({ width, height })
      
      if (width < 768) {
        setBreakpoint('mobile')
      } else if (width < 1024) {
        setBreakpoint('tablet')
      } else {
        setBreakpoint('desktop')
      }
    }

    handleResize()
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  return { breakpoint, windowSize }
}
```

### CSS Grid 替代方案

```tsx
// 使用 CSS Grid 的佈局版本
export const GridTwoColumnLayout = ({ sidebar, children }: TwoColumnLayoutProps) => {
  const { sidebarCollapsed } = useLayout()
  
  return (
    <div className={cn(
      'min-h-screen grid transition-all duration-300',
      sidebarCollapsed 
        ? 'grid-cols-1' 
        : 'grid-cols-1 lg:grid-cols-[280px_1fr]',
      'lg:gap-6'
    )}>
      <aside className={cn(
        'bg-white dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700',
        sidebarCollapsed && 'hidden lg:block'
      )}>
        {sidebar}
      </aside>
      
      <main className="min-w-0">
        {children}
      </main>
    </div>
  )
}
```

## 常見陷阱與解決方案

### 1. 焦點陷阱
```tsx
// ❌ 錯誤：行動版側邊欄開啟時焦點可能跑到背景
const BadSidebar = () => (
  <div className="fixed inset-0">
    <div className="sidebar">...</div>
  </div>
)

// ✅ 正確：使用焦點陷阱
import { FocusTrap } from '@headlessui/react'

const GoodSidebar = () => (
  <FocusTrap>
    <div className="fixed inset-0">
      <div className="sidebar">...</div>
    </div>
  </FocusTrap>
)
```

### 2. 滾動位置保持
```tsx
// 側邊欄滾動位置記憶
const useSidebarScroll = () => {
  const scrollRef = useRef<HTMLDivElement>(null)
  
  useEffect(() => {
    const savedPosition = sessionStorage.getItem('sidebar-scroll')
    if (savedPosition && scrollRef.current) {
      scrollRef.current.scrollTop = parseInt(savedPosition)
    }
  }, [])

  const handleScroll = useCallback(() => {
    if (scrollRef.current) {
      sessionStorage.setItem('sidebar-scroll', scrollRef.current.scrollTop.toString())
    }
  }, [])

  return { scrollRef, handleScroll }
}
```

### 3. 路由變化處理
```tsx
// 路由變化時自動關閉行動版側邊欄
export const useRouteChange = () => {
  const pathname = usePathname()
  const { breakpoint, sidebarCollapsed, toggleSidebar } = useLayout()
  
  useEffect(() => {
    if (breakpoint === 'mobile' && !sidebarCollapsed) {
      toggleSidebar()
    }
  }, [pathname, breakpoint, sidebarCollapsed, toggleSidebar])
}
```

## 無障礙設計要點

1. **Landmark 角色**：正確使用 `nav`、`main`、`aside` 等語意化標籤
2. **Skip Links**：提供跳至主要內容的連結
3. **焦點管理**：確保鍵盤用戶能順暢導航
4. **ARIA 屬性**：適當使用 `aria-expanded`、`aria-current` 等
5. **對比度**：確保導航項目有足夠的視覺對比

```tsx
// 完整的無障礙導航項目
const AccessibleNavItem = ({ item, isActive }: { item: NavigationItem, isActive: boolean }) => (
  <Link
    href={item.href}
    className={cn(
      'flex items-center gap-3 px-3 py-2 rounded-lg',
      'focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500',
      'hover:bg-gray-100 dark:hover:bg-gray-800',
      isActive && 'bg-blue-50 text-blue-700 dark:bg-blue-950 dark:text-blue-300'
    )}
    aria-current={isActive ? 'page' : undefined}
    role="menuitem"
  >
    {item.icon && (
      <item.icon 
        className="w-5 h-5" 
        aria-hidden="true" 
      />
    )}
    <span>{item.title}</span>
    {item.badge && (
      <span 
        className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full"
        aria-label={`${item.badge} 個通知`}
      >
        {item.badge}
      </span>
    )}
  </Link>
)
```

這個兩欄佈局系統提供了完整的功能和良好的用戶體驗，可以適應各種應用場景的需求。記住要根據具體的內容和用戶需求來調整佈局的細節。